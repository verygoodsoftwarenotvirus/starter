// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package generated

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"time"
)

type AuditLogEventType string

const (
	AuditLogEventTypeOther    AuditLogEventType = "other"
	AuditLogEventTypeCreated  AuditLogEventType = "created"
	AuditLogEventTypeUpdated  AuditLogEventType = "updated"
	AuditLogEventTypeArchived AuditLogEventType = "archived"
)

func (e *AuditLogEventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditLogEventType(s)
	case string:
		*e = AuditLogEventType(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditLogEventType: %T", src)
	}
	return nil
}

type NullAuditLogEventType struct {
	AuditLogEventType AuditLogEventType
	Valid             bool // Valid is true if AuditLogEventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditLogEventType) Scan(value interface{}) error {
	if value == nil {
		ns.AuditLogEventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditLogEventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditLogEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditLogEventType), nil
}

func (e AuditLogEventType) Valid() bool {
	switch e {
	case AuditLogEventTypeOther,
		AuditLogEventTypeCreated,
		AuditLogEventTypeUpdated,
		AuditLogEventTypeArchived:
		return true
	}
	return false
}

func AllAuditLogEventTypeValues() []AuditLogEventType {
	return []AuditLogEventType{
		AuditLogEventTypeOther,
		AuditLogEventTypeCreated,
		AuditLogEventTypeUpdated,
		AuditLogEventTypeArchived,
	}
}

type InvitationState string

const (
	InvitationStatePending   InvitationState = "pending"
	InvitationStateCancelled InvitationState = "cancelled"
	InvitationStateAccepted  InvitationState = "accepted"
	InvitationStateRejected  InvitationState = "rejected"
)

func (e *InvitationState) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvitationState(s)
	case string:
		*e = InvitationState(s)
	default:
		return fmt.Errorf("unsupported scan type for InvitationState: %T", src)
	}
	return nil
}

type NullInvitationState struct {
	InvitationState InvitationState
	Valid           bool // Valid is true if InvitationState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvitationState) Scan(value interface{}) error {
	if value == nil {
		ns.InvitationState, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvitationState.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvitationState) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvitationState), nil
}

func (e InvitationState) Valid() bool {
	switch e {
	case InvitationStatePending,
		InvitationStateCancelled,
		InvitationStateAccepted,
		InvitationStateRejected:
		return true
	}
	return false
}

func AllInvitationStateValues() []InvitationState {
	return []InvitationState{
		InvitationStatePending,
		InvitationStateCancelled,
		InvitationStateAccepted,
		InvitationStateRejected,
	}
}

type Oauth2ClientTokenScopes string

const (
	Oauth2ClientTokenScopesUnknown       Oauth2ClientTokenScopes = "unknown"
	Oauth2ClientTokenScopesAccountMember Oauth2ClientTokenScopes = "account_member"
	Oauth2ClientTokenScopesAccountAdmin  Oauth2ClientTokenScopes = "account_admin"
	Oauth2ClientTokenScopesServiceAdmin  Oauth2ClientTokenScopes = "service_admin"
)

func (e *Oauth2ClientTokenScopes) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Oauth2ClientTokenScopes(s)
	case string:
		*e = Oauth2ClientTokenScopes(s)
	default:
		return fmt.Errorf("unsupported scan type for Oauth2ClientTokenScopes: %T", src)
	}
	return nil
}

type NullOauth2ClientTokenScopes struct {
	Oauth2ClientTokenScopes Oauth2ClientTokenScopes
	Valid                   bool // Valid is true if Oauth2ClientTokenScopes is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOauth2ClientTokenScopes) Scan(value interface{}) error {
	if value == nil {
		ns.Oauth2ClientTokenScopes, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Oauth2ClientTokenScopes.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOauth2ClientTokenScopes) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Oauth2ClientTokenScopes), nil
}

func (e Oauth2ClientTokenScopes) Valid() bool {
	switch e {
	case Oauth2ClientTokenScopesUnknown,
		Oauth2ClientTokenScopesAccountMember,
		Oauth2ClientTokenScopesAccountAdmin,
		Oauth2ClientTokenScopesServiceAdmin:
		return true
	}
	return false
}

func AllOauth2ClientTokenScopesValues() []Oauth2ClientTokenScopes {
	return []Oauth2ClientTokenScopes{
		Oauth2ClientTokenScopesUnknown,
		Oauth2ClientTokenScopesAccountMember,
		Oauth2ClientTokenScopesAccountAdmin,
		Oauth2ClientTokenScopesServiceAdmin,
	}
}

type SettingType string

const (
	SettingTypeUser       SettingType = "user"
	SettingTypeAccount    SettingType = "account"
	SettingTypeMembership SettingType = "membership"
)

func (e *SettingType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SettingType(s)
	case string:
		*e = SettingType(s)
	default:
		return fmt.Errorf("unsupported scan type for SettingType: %T", src)
	}
	return nil
}

type NullSettingType struct {
	SettingType SettingType
	Valid       bool // Valid is true if SettingType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSettingType) Scan(value interface{}) error {
	if value == nil {
		ns.SettingType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SettingType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSettingType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SettingType), nil
}

func (e SettingType) Valid() bool {
	switch e {
	case SettingTypeUser,
		SettingTypeAccount,
		SettingTypeMembership:
		return true
	}
	return false
}

func AllSettingTypeValues() []SettingType {
	return []SettingType{
		SettingTypeUser,
		SettingTypeAccount,
		SettingTypeMembership,
	}
}

type TimeZone string

const (
	TimeZoneUTC        TimeZone = "UTC"
	TimeZoneUSPacific  TimeZone = "US/Pacific"
	TimeZoneUSMountain TimeZone = "US/Mountain"
	TimeZoneUSCentral  TimeZone = "US/Central"
	TimeZoneUSEastern  TimeZone = "US/Eastern"
)

func (e *TimeZone) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TimeZone(s)
	case string:
		*e = TimeZone(s)
	default:
		return fmt.Errorf("unsupported scan type for TimeZone: %T", src)
	}
	return nil
}

type NullTimeZone struct {
	TimeZone TimeZone
	Valid    bool // Valid is true if TimeZone is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTimeZone) Scan(value interface{}) error {
	if value == nil {
		ns.TimeZone, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TimeZone.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTimeZone) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TimeZone), nil
}

func (e TimeZone) Valid() bool {
	switch e {
	case TimeZoneUTC,
		TimeZoneUSPacific,
		TimeZoneUSMountain,
		TimeZoneUSCentral,
		TimeZoneUSEastern:
		return true
	}
	return false
}

func AllTimeZoneValues() []TimeZone {
	return []TimeZone{
		TimeZoneUTC,
		TimeZoneUSPacific,
		TimeZoneUSMountain,
		TimeZoneUSCentral,
		TimeZoneUSEastern,
	}
}

type UserNotificationStatus string

const (
	UserNotificationStatusUnread    UserNotificationStatus = "unread"
	UserNotificationStatusRead      UserNotificationStatus = "read"
	UserNotificationStatusDismissed UserNotificationStatus = "dismissed"
)

func (e *UserNotificationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserNotificationStatus(s)
	case string:
		*e = UserNotificationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserNotificationStatus: %T", src)
	}
	return nil
}

type NullUserNotificationStatus struct {
	UserNotificationStatus UserNotificationStatus
	Valid                  bool // Valid is true if UserNotificationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserNotificationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserNotificationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserNotificationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserNotificationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserNotificationStatus), nil
}

func (e UserNotificationStatus) Valid() bool {
	switch e {
	case UserNotificationStatusUnread,
		UserNotificationStatusRead,
		UserNotificationStatusDismissed:
		return true
	}
	return false
}

func AllUserNotificationStatusValues() []UserNotificationStatus {
	return []UserNotificationStatus{
		UserNotificationStatusUnread,
		UserNotificationStatusRead,
		UserNotificationStatusDismissed,
	}
}

type WebhookEvent string

const (
	WebhookEventWebhookCreated  WebhookEvent = "webhook_created"
	WebhookEventWebhookUpdated  WebhookEvent = "webhook_updated"
	WebhookEventWebhookArchived WebhookEvent = "webhook_archived"
)

func (e *WebhookEvent) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WebhookEvent(s)
	case string:
		*e = WebhookEvent(s)
	default:
		return fmt.Errorf("unsupported scan type for WebhookEvent: %T", src)
	}
	return nil
}

type NullWebhookEvent struct {
	WebhookEvent WebhookEvent
	Valid        bool // Valid is true if WebhookEvent is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWebhookEvent) Scan(value interface{}) error {
	if value == nil {
		ns.WebhookEvent, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WebhookEvent.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWebhookEvent) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WebhookEvent), nil
}

func (e WebhookEvent) Valid() bool {
	switch e {
	case WebhookEventWebhookCreated,
		WebhookEventWebhookUpdated,
		WebhookEventWebhookArchived:
		return true
	}
	return false
}

func AllWebhookEventValues() []WebhookEvent {
	return []WebhookEvent{
		WebhookEventWebhookCreated,
		WebhookEventWebhookUpdated,
		WebhookEventWebhookArchived,
	}
}

type AccountUserMemberships struct {
	CreatedAt        time.Time
	LastUpdatedAt    sql.NullTime
	ArchivedAt       sql.NullTime
	ID               string
	BelongsToAccount string
	BelongsToUser    string
	AccountRole      string
	DefaultAccount   bool
}

type Oauth2ClientTokens struct {
	AccessExpiresAt     time.Time
	CodeExpiresAt       time.Time
	RefreshExpiresAt    time.Time
	RefreshCreatedAt    time.Time
	CodeCreatedAt       time.Time
	AccessCreatedAt     time.Time
	CodeChallenge       string
	CodeChallengeMethod string
	Scope               Oauth2ClientTokenScopes
	ClientID            string
	Access              string
	Code                string
	ID                  string
	Refresh             string
	RedirectUri         string
	BelongsToUser       string
}

type Oauth2Clients struct {
	ID           string
	Name         string
	Description  string
	ClientID     string
	ClientSecret string
	CreatedAt    time.Time
	ArchivedAt   sql.NullTime
}

type ServiceSettings struct {
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
	ID            string
	Name          string
	Type          SettingType
	Description   string
	Enumeration   string
	DefaultValue  sql.NullString
	AdminsOnly    bool
}

type UserNotifications struct {
	ID            string
	Content       string
	Status        UserNotificationStatus
	BelongsToUser string
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
}

type Webhooks struct {
	ID               string
	Name             string
	ContentType      string
	URL              string
	Method           string
	CreatedAt        time.Time
	LastUpdatedAt    sql.NullTime
	ArchivedAt       sql.NullTime
	BelongsToAccount string
}
