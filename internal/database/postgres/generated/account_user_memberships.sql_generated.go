// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: account_user_memberships.sql

package generated

import (
	"context"
)

const addUserToAccount = `-- name: AddUserToAccount :exec

INSERT INTO account_user_memberships (
	id,
	belongs_to_account,
	belongs_to_user,
	account_role
) VALUES (
	$1,
	$2,
	$3,
	$4
)
`

type AddUserToAccountParams struct {
	ID               string
	BelongsToAccount string
	BelongsToUser    string
	AccountRole      string
}

func (q *Queries) AddUserToAccount(ctx context.Context, db DBTX, arg *AddUserToAccountParams) error {
	_, err := db.ExecContext(ctx, addUserToAccount,
		arg.ID,
		arg.BelongsToAccount,
		arg.BelongsToUser,
		arg.AccountRole,
	)
	return err
}

const createAccountUserMembershipForNewUser = `-- name: CreateAccountUserMembershipForNewUser :exec

INSERT INTO account_user_memberships (
	id,
	belongs_to_account,
	belongs_to_user,
	default_account,
	account_role
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5
)
`

type CreateAccountUserMembershipForNewUserParams struct {
	ID               string
	BelongsToAccount string
	BelongsToUser    string
	AccountRole      string
	DefaultAccount   bool
}

func (q *Queries) CreateAccountUserMembershipForNewUser(ctx context.Context, db DBTX, arg *CreateAccountUserMembershipForNewUserParams) error {
	_, err := db.ExecContext(ctx, createAccountUserMembershipForNewUser,
		arg.ID,
		arg.BelongsToAccount,
		arg.BelongsToUser,
		arg.DefaultAccount,
		arg.AccountRole,
	)
	return err
}

const getAccountUserMembershipsForUser = `-- name: GetAccountUserMembershipsForUser :many

SELECT
	account_user_memberships.id,
	account_user_memberships.belongs_to_account,
	account_user_memberships.belongs_to_user,
	account_user_memberships.default_account,
	account_user_memberships.account_role,
	account_user_memberships.created_at,
	account_user_memberships.last_updated_at,
	account_user_memberships.archived_at
FROM account_user_memberships
	JOIN accounts ON accounts.id = account_user_memberships.belongs_to_account
WHERE account_user_memberships.archived_at IS NULL
	AND account_user_memberships.belongs_to_user = $1
`

func (q *Queries) GetAccountUserMembershipsForUser(ctx context.Context, db DBTX, belongsToUser string) ([]*AccountUserMemberships, error) {
	rows, err := db.QueryContext(ctx, getAccountUserMembershipsForUser, belongsToUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AccountUserMemberships{}
	for rows.Next() {
		var i AccountUserMemberships
		if err := rows.Scan(
			&i.ID,
			&i.BelongsToAccount,
			&i.BelongsToUser,
			&i.DefaultAccount,
			&i.AccountRole,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultAccountIDForUser = `-- name: GetDefaultAccountIDForUser :one

SELECT accounts.id
FROM accounts
	JOIN account_user_memberships ON account_user_memberships.belongs_to_account = accounts.id
WHERE account_user_memberships.belongs_to_user = $1
	AND account_user_memberships.default_account = TRUE
`

func (q *Queries) GetDefaultAccountIDForUser(ctx context.Context, db DBTX, belongsToUser string) (string, error) {
	row := db.QueryRowContext(ctx, getDefaultAccountIDForUser, belongsToUser)
	var id string
	err := row.Scan(&id)
	return id, err
}

const markAccountUserMembershipAsUserDefault = `-- name: MarkAccountUserMembershipAsUserDefault :exec

UPDATE account_user_memberships SET
	default_account = (belongs_to_user = $1 AND belongs_to_account = $2)
WHERE archived_at IS NULL
	AND belongs_to_user = $1
`

type MarkAccountUserMembershipAsUserDefaultParams struct {
	BelongsToUser    string
	BelongsToAccount string
}

func (q *Queries) MarkAccountUserMembershipAsUserDefault(ctx context.Context, db DBTX, arg *MarkAccountUserMembershipAsUserDefaultParams) error {
	_, err := db.ExecContext(ctx, markAccountUserMembershipAsUserDefault, arg.BelongsToUser, arg.BelongsToAccount)
	return err
}

const modifyAccountUserPermissions = `-- name: ModifyAccountUserPermissions :exec

UPDATE account_user_memberships SET
	account_role = $1
WHERE belongs_to_account = $2
	AND belongs_to_user = $3
`

type ModifyAccountUserPermissionsParams struct {
	AccountRole      string
	BelongsToAccount string
	BelongsToUser    string
}

func (q *Queries) ModifyAccountUserPermissions(ctx context.Context, db DBTX, arg *ModifyAccountUserPermissionsParams) error {
	_, err := db.ExecContext(ctx, modifyAccountUserPermissions, arg.AccountRole, arg.BelongsToAccount, arg.BelongsToUser)
	return err
}

const removeUserFromAccount = `-- name: RemoveUserFromAccount :exec

UPDATE account_user_memberships SET
	archived_at = NOW(),
	default_account = 'false'
WHERE account_user_memberships.archived_at IS NULL
	AND account_user_memberships.belongs_to_account = $1
	AND account_user_memberships.belongs_to_user = $2
`

type RemoveUserFromAccountParams struct {
	BelongsToAccount string
	BelongsToUser    string
}

func (q *Queries) RemoveUserFromAccount(ctx context.Context, db DBTX, arg *RemoveUserFromAccountParams) error {
	_, err := db.ExecContext(ctx, removeUserFromAccount, arg.BelongsToAccount, arg.BelongsToUser)
	return err
}

const transferAccountMembership = `-- name: TransferAccountMembership :exec

UPDATE account_user_memberships SET
	belongs_to_user = $1
WHERE archived_at IS NULL
	AND belongs_to_account = $2
	AND belongs_to_user = $1
`

type TransferAccountMembershipParams struct {
	BelongsToUser    string
	BelongsToAccount string
}

func (q *Queries) TransferAccountMembership(ctx context.Context, db DBTX, arg *TransferAccountMembershipParams) error {
	_, err := db.ExecContext(ctx, transferAccountMembership, arg.BelongsToUser, arg.BelongsToAccount)
	return err
}

const transferAccountOwnership = `-- name: TransferAccountOwnership :exec

UPDATE accounts SET
	belongs_to_user = $1
WHERE archived_at IS NULL
	AND belongs_to_user = $2
	AND id = $3
`

type TransferAccountOwnershipParams struct {
	NewOwner  string
	OldOwner  string
	AccountID string
}

func (q *Queries) TransferAccountOwnership(ctx context.Context, db DBTX, arg *TransferAccountOwnershipParams) error {
	_, err := db.ExecContext(ctx, transferAccountOwnership, arg.NewOwner, arg.OldOwner, arg.AccountID)
	return err
}

const userIsAccountMember = `-- name: UserIsAccountMember :one

SELECT EXISTS (
	SELECT account_user_memberships.id
	FROM account_user_memberships
	WHERE account_user_memberships.archived_at IS NULL
		AND account_user_memberships.belongs_to_account = $1
		AND account_user_memberships.belongs_to_user = $2
)
`

type UserIsAccountMemberParams struct {
	BelongsToAccount string
	BelongsToUser    string
}

func (q *Queries) UserIsAccountMember(ctx context.Context, db DBTX, arg *UserIsAccountMemberParams) (bool, error) {
	row := db.QueryRowContext(ctx, userIsAccountMember, arg.BelongsToAccount, arg.BelongsToUser)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
