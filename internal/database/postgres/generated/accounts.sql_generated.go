// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: accounts.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const addToAccountDuringCreation = `-- name: AddToAccountDuringCreation :exec

INSERT INTO account_user_memberships (
	id,
	belongs_to_account,
	belongs_to_user,
	account_role
) VALUES (
	$1,
	$2,
	$3,
	$4
)
`

type AddToAccountDuringCreationParams struct {
	ID               string
	BelongsToAccount string
	BelongsToUser    string
	AccountRole      string
}

func (q *Queries) AddToAccountDuringCreation(ctx context.Context, db DBTX, arg *AddToAccountDuringCreationParams) error {
	_, err := db.ExecContext(ctx, addToAccountDuringCreation,
		arg.ID,
		arg.BelongsToAccount,
		arg.BelongsToUser,
		arg.AccountRole,
	)
	return err
}

const archiveAccount = `-- name: ArchiveAccount :execrows

UPDATE accounts SET
	last_updated_at = NOW(),
	archived_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_user = $1
	AND id = $2
`

type ArchiveAccountParams struct {
	BelongsToUser string
	ID            string
}

func (q *Queries) ArchiveAccount(ctx context.Context, db DBTX, arg *ArchiveAccountParams) (int64, error) {
	result, err := db.ExecContext(ctx, archiveAccount, arg.BelongsToUser, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createAccount = `-- name: CreateAccount :exec

INSERT INTO accounts (
	id,
	name,
	billing_status,
	contact_phone,
	belongs_to_user,
	address_line_1,
	address_line_2,
	city,
	state,
	zip_code,
	country,
	latitude,
	longitude,
	webhook_hmac_secret
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10,
	$11,
	$12,
	$13,
	$14
)
`

type CreateAccountParams struct {
	AddressLine2      string
	ID                string
	BillingStatus     string
	ContactPhone      string
	BelongsToUser     string
	AddressLine1      string
	Name              string
	City              string
	Country           string
	ZipCode           string
	State             string
	WebhookHmacSecret string
	Longitude         sql.NullString
	Latitude          sql.NullString
}

func (q *Queries) CreateAccount(ctx context.Context, db DBTX, arg *CreateAccountParams) error {
	_, err := db.ExecContext(ctx, createAccount,
		arg.ID,
		arg.Name,
		arg.BillingStatus,
		arg.ContactPhone,
		arg.BelongsToUser,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.WebhookHmacSecret,
	)
	return err
}

const getAccountByIDWithMemberships = `-- name: GetAccountByIDWithMemberships :many

SELECT
	accounts.id,
	accounts.name,
	accounts.billing_status,
	accounts.contact_phone,
	accounts.payment_processor_customer_id,
	accounts.subscription_plan_id,
	accounts.belongs_to_user,
	accounts.time_zone,
	accounts.address_line_1,
	accounts.address_line_2,
	accounts.city,
	accounts.state,
	accounts.zip_code,
	accounts.country,
	accounts.latitude,
	accounts.longitude,
	accounts.last_payment_provider_sync_occurred_at,
	accounts.webhook_hmac_secret,
	accounts.created_at,
	accounts.last_updated_at,
	accounts.archived_at,
	users.id as user_id,
	users.username as user_username,
	users.avatar_src as user_avatar_src,
	users.email_address as user_email_address,
	users.hashed_password as user_hashed_password,
	users.password_last_changed_at as user_password_last_changed_at,
	users.requires_password_change as user_requires_password_change,
	users.two_factor_secret as user_two_factor_secret,
	users.two_factor_secret_verified_at as user_two_factor_secret_verified_at,
	users.service_role as user_service_role,
	users.user_account_status as user_user_account_status,
	users.user_account_status_explanation as user_user_account_status_explanation,
	users.birthday as user_birthday,
	users.email_address_verification_token as user_email_address_verification_token,
	users.email_address_verified_at as user_email_address_verified_at,
	users.first_name as user_first_name,
	users.last_name as user_last_name,
	users.last_accepted_terms_of_service as user_last_accepted_terms_of_service,
	users.last_accepted_privacy_policy as user_last_accepted_privacy_policy,
	users.last_indexed_at as user_last_indexed_at,
	users.created_at as user_created_at,
	users.last_updated_at as user_last_updated_at,
	users.archived_at as user_archived_at,
	account_user_memberships.id as membership_id,
	account_user_memberships.belongs_to_account as membership_belongs_to_account,
	account_user_memberships.belongs_to_user as membership_belongs_to_user,
	account_user_memberships.default_account as membership_default_account,
	account_user_memberships.account_role as membership_account_role,
	account_user_memberships.created_at as membership_created_at,
	account_user_memberships.last_updated_at as membership_last_updated_at,
	account_user_memberships.archived_at as membership_archived_at
FROM accounts
	JOIN account_user_memberships ON account_user_memberships.belongs_to_account = accounts.id
	JOIN users ON account_user_memberships.belongs_to_user = users.id
WHERE accounts.archived_at IS NULL
	AND account_user_memberships.archived_at IS NULL
	AND accounts.id = $1
`

type GetAccountByIDWithMembershipsRow struct {
	MembershipCreatedAt               time.Time
	CreatedAt                         time.Time
	UserCreatedAt                     time.Time
	UserLastAcceptedPrivacyPolicy     sql.NullTime
	UserEmailAddressVerifiedAt        sql.NullTime
	UserLastUpdatedAt                 sql.NullTime
	MembershipLastUpdatedAt           sql.NullTime
	UserLastIndexedAt                 sql.NullTime
	MembershipArchivedAt              sql.NullTime
	UserLastAcceptedTermsOfService    sql.NullTime
	UserArchivedAt                    sql.NullTime
	UserBirthday                      sql.NullTime
	UserTwoFactorSecretVerifiedAt     sql.NullTime
	UserPasswordLastChangedAt         sql.NullTime
	ArchivedAt                        sql.NullTime
	LastUpdatedAt                     sql.NullTime
	LastPaymentProviderSyncOccurredAt sql.NullTime
	Country                           string
	UserServiceRole                   string
	Name                              string
	BillingStatus                     string
	UserID                            string
	UserUsername                      string
	ContactPhone                      string
	UserEmailAddress                  string
	UserHashedPassword                string
	ID                                string
	MembershipAccountRole             string
	UserTwoFactorSecret               string
	ZipCode                           string
	MembershipBelongsToAccount        string
	UserUserAccountStatus             string
	UserUserAccountStatusExplanation  string
	State                             string
	WebhookHmacSecret                 string
	City                              string
	UserFirstName                     string
	UserLastName                      string
	AddressLine2                      string
	AddressLine1                      string
	TimeZone                          TimeZone
	BelongsToUser                     string
	MembershipBelongsToUser           string
	PaymentProcessorCustomerID        string
	MembershipID                      string
	UserEmailAddressVerificationToken sql.NullString
	SubscriptionPlanID                sql.NullString
	UserAvatarSrc                     sql.NullString
	Latitude                          sql.NullString
	Longitude                         sql.NullString
	MembershipDefaultAccount          bool
	UserRequiresPasswordChange        bool
}

func (q *Queries) GetAccountByIDWithMemberships(ctx context.Context, db DBTX, id string) ([]*GetAccountByIDWithMembershipsRow, error) {
	rows, err := db.QueryContext(ctx, getAccountByIDWithMemberships, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAccountByIDWithMembershipsRow{}
	for rows.Next() {
		var i GetAccountByIDWithMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BillingStatus,
			&i.ContactPhone,
			&i.PaymentProcessorCustomerID,
			&i.SubscriptionPlanID,
			&i.BelongsToUser,
			&i.TimeZone,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.LastPaymentProviderSyncOccurredAt,
			&i.WebhookHmacSecret,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.UserID,
			&i.UserUsername,
			&i.UserAvatarSrc,
			&i.UserEmailAddress,
			&i.UserHashedPassword,
			&i.UserPasswordLastChangedAt,
			&i.UserRequiresPasswordChange,
			&i.UserTwoFactorSecret,
			&i.UserTwoFactorSecretVerifiedAt,
			&i.UserServiceRole,
			&i.UserUserAccountStatus,
			&i.UserUserAccountStatusExplanation,
			&i.UserBirthday,
			&i.UserEmailAddressVerificationToken,
			&i.UserEmailAddressVerifiedAt,
			&i.UserFirstName,
			&i.UserLastName,
			&i.UserLastAcceptedTermsOfService,
			&i.UserLastAcceptedPrivacyPolicy,
			&i.UserLastIndexedAt,
			&i.UserCreatedAt,
			&i.UserLastUpdatedAt,
			&i.UserArchivedAt,
			&i.MembershipID,
			&i.MembershipBelongsToAccount,
			&i.MembershipBelongsToUser,
			&i.MembershipDefaultAccount,
			&i.MembershipAccountRole,
			&i.MembershipCreatedAt,
			&i.MembershipLastUpdatedAt,
			&i.MembershipArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsForUser = `-- name: GetAccountsForUser :many

SELECT
	accounts.id,
	accounts.name,
	accounts.billing_status,
	accounts.contact_phone,
	accounts.payment_processor_customer_id,
	accounts.subscription_plan_id,
	accounts.belongs_to_user,
	accounts.time_zone,
	accounts.address_line_1,
	accounts.address_line_2,
	accounts.city,
	accounts.state,
	accounts.zip_code,
	accounts.country,
	accounts.latitude,
	accounts.longitude,
	accounts.last_payment_provider_sync_occurred_at,
	accounts.webhook_hmac_secret,
	accounts.created_at,
	accounts.last_updated_at,
	accounts.archived_at,
	(
		SELECT COUNT(accounts.id)
		FROM accounts
			JOIN account_user_memberships ON account_user_memberships.belongs_to_account = accounts.id
		WHERE accounts.archived_at IS NULL
			AND account_user_memberships.belongs_to_user = $1
			AND accounts.created_at > COALESCE($2, (SELECT NOW() - '999 years'::INTERVAL))
			AND accounts.created_at < COALESCE($3, (SELECT NOW() + '999 years'::INTERVAL))
			AND (
				accounts.last_updated_at IS NULL
				OR accounts.last_updated_at > COALESCE($4, (SELECT NOW() - '999 years'::INTERVAL))
			)
			AND (
				accounts.last_updated_at IS NULL
				OR accounts.last_updated_at < COALESCE($5, (SELECT NOW() + '999 years'::INTERVAL))
			)
	) as filtered_count,
	(
		SELECT COUNT(accounts.id)
		FROM accounts
		WHERE accounts.archived_at IS NULL
	) AS total_count
FROM accounts
	JOIN account_user_memberships ON account_user_memberships.belongs_to_account = accounts.id
	JOIN users ON account_user_memberships.belongs_to_user = users.id
WHERE accounts.archived_at IS NULL
	AND account_user_memberships.archived_at IS NULL
	AND account_user_memberships.belongs_to_user = $1
	AND accounts.created_at > COALESCE($2, (SELECT NOW() - '999 years'::INTERVAL))
	AND accounts.created_at < COALESCE($3, (SELECT NOW() + '999 years'::INTERVAL))
	AND (
		accounts.last_updated_at IS NULL
		OR accounts.last_updated_at > COALESCE($4, (SELECT NOW() - '999 years'::INTERVAL))
	)
	AND (
		accounts.last_updated_at IS NULL
		OR accounts.last_updated_at < COALESCE($5, (SELECT NOW() + '999 years'::INTERVAL))
	)
LIMIT $7
OFFSET $6
`

type GetAccountsForUserParams struct {
	BelongsToUser string
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetAccountsForUserRow struct {
	CreatedAt                         time.Time
	LastPaymentProviderSyncOccurredAt sql.NullTime
	LastUpdatedAt                     sql.NullTime
	ArchivedAt                        sql.NullTime
	AddressLine1                      string
	State                             string
	BelongsToUser                     string
	TimeZone                          TimeZone
	PaymentProcessorCustomerID        string
	AddressLine2                      string
	City                              string
	ID                                string
	ZipCode                           string
	Country                           string
	ContactPhone                      string
	BillingStatus                     string
	Name                              string
	WebhookHmacSecret                 string
	SubscriptionPlanID                sql.NullString
	Longitude                         sql.NullString
	Latitude                          sql.NullString
	FilteredCount                     int64
	TotalCount                        int64
}

func (q *Queries) GetAccountsForUser(ctx context.Context, db DBTX, arg *GetAccountsForUserParams) ([]*GetAccountsForUserRow, error) {
	rows, err := db.QueryContext(ctx, getAccountsForUser,
		arg.BelongsToUser,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAccountsForUserRow{}
	for rows.Next() {
		var i GetAccountsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BillingStatus,
			&i.ContactPhone,
			&i.PaymentProcessorCustomerID,
			&i.SubscriptionPlanID,
			&i.BelongsToUser,
			&i.TimeZone,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.LastPaymentProviderSyncOccurredAt,
			&i.WebhookHmacSecret,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :execrows

UPDATE accounts SET
	name = $1,
	contact_phone = $2,
	address_line_1 = $3,
	address_line_2 = $4,
	city = $5,
	state = $6,
	zip_code = $7,
	country = $8,
	latitude = $9,
	longitude = $10,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_user = $11
	AND id = $12
`

type UpdateAccountParams struct {
	Name          string
	ContactPhone  string
	AddressLine1  string
	AddressLine2  string
	City          string
	State         string
	ZipCode       string
	Country       string
	BelongsToUser string
	ID            string
	Latitude      sql.NullString
	Longitude     sql.NullString
}

func (q *Queries) UpdateAccount(ctx context.Context, db DBTX, arg *UpdateAccountParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateAccount,
		arg.Name,
		arg.ContactPhone,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.BelongsToUser,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateAccountWebhookEncryptionKey = `-- name: UpdateAccountWebhookEncryptionKey :execrows

UPDATE accounts SET
	webhook_hmac_secret = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_user = $2
	AND id = $3
`

type UpdateAccountWebhookEncryptionKeyParams struct {
	WebhookHmacSecret string
	BelongsToUser     string
	ID                string
}

func (q *Queries) UpdateAccountWebhookEncryptionKey(ctx context.Context, db DBTX, arg *UpdateAccountWebhookEncryptionKeyParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateAccountWebhookEncryptionKey, arg.WebhookHmacSecret, arg.BelongsToUser, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
